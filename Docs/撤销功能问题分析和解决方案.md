# 撤销功能问题分析和解决方案评估

## 问题分析

### 当前问题
用户点击撤销按钮时显示"撤销记录不存在或已撤销"的错误。

### 根本原因
1. **数据库表限制**：`t_contract_edit_history`表中`contract_id`字段是`NOT NULL`
2. **保存逻辑缺陷**：在`AIChatServiceImpl.parseAndExecuteCommand()`方法中，只有当`contractId != null`时才会调用`saveEditHistory()`保存编辑历史
3. **新建合同场景**：当用户新建合同时，`contractId`为`null`，编辑历史不会被保存到数据库
4. **撤销逻辑依赖**：`undoAgentAction()`方法只能从数据库查找编辑历史，新建合同场景下找不到记录

### 代码位置
- **保存逻辑**：`backend/src/main/java/com/software/contract_system/service/impl/AIChatServiceImpl.java:347-350`
- **撤销逻辑**：`backend/src/main/java/com/software/contract_system/service/impl/AIChatServiceImpl.java:194-215`
- **数据库表**：`database/db_upgrade_v6_drafting.sql:84` (contract_id bigint NOT NULL)

## 解决方案评估

### 方案1：内存存储方案（推荐）
**实现方式**：
- 添加`ConcurrentHashMap<String, ContractEditHistory>`存储sessionId -> undoToken -> history的映射
- 当`contractId == null`时，将编辑历史存储到内存Map
- 撤销时先从数据库查找，找不到再从内存Map查找
- 需要添加清理机制（会话过期、定期清理）

**开发难度**：⭐⭐⭐ 中等（3-4小时）
- 需要添加内存存储结构
- 需要修改保存和撤销逻辑
- 需要添加清理机制（可选，但推荐）

**优点**：
- ✅ 不需要修改数据库结构
- ✅ 实现相对简单
- ✅ 不影响已有功能
- ✅ 新建合同场景下性能好

**缺点**：
- ❌ 服务器重启后数据丢失
- ❌ 需要内存管理（但影响很小）
- ❌ 不支持跨服务器实例（单机部署无影响）

**适用场景**：单机部署，新建合同撤销需求

---

### 方案2：数据库允许NULL方案
**实现方式**：
- 修改数据库表，将`contract_id`改为`DEFAULT NULL`
- 修改保存逻辑，允许`contractId`为`null`时也保存到数据库
- 修改撤销逻辑：
  - 如果`contractId`为`null`，只返回内容，不更新数据库中的合同表
  - 如果`contractId`不为`null`，正常更新合同表

**开发难度**：⭐⭐⭐ 中等（2-3小时）
- 需要数据库迁移脚本
- 需要修改保存逻辑（移除if判断）
- 需要修改撤销逻辑（判断contractId）

**优点**：
- ✅ 数据持久化，服务器重启不丢失
- ✅ 逻辑清晰统一
- ✅ 支持跨服务器实例

**缺点**：
- ❌ 需要数据库迁移（有风险，需要测试）
- ❌ 数据库中有NULL记录需要清理策略
- ❌ 撤销逻辑需要判断两种场景

**适用场景**：需要数据持久化，支持分布式部署

---

### 方案3：混合方案（内存+持久化）
**实现方式**：
- 新建合同时使用内存存储
- 合同保存后，将内存中的历史记录迁移到数据库
- 撤销时先从内存查找，找不到再从数据库查找

**开发难度**：⭐⭐⭐⭐ 较难（4-5小时）
- 需要实现内存存储
- 需要实现数据迁移逻辑
- 需要处理合同保存时的迁移
- 逻辑较复杂

**优点**：
- ✅ 兼顾性能和持久化
- ✅ 新建合同性能好
- ✅ 已保存合同数据持久化

**缺点**：
- ❌ 实现复杂度高
- ❌ 需要处理数据迁移的边界情况
- ❌ 维护成本较高

**适用场景**：对性能和数据持久化都有要求

---

### 方案4：使用sessionId存储（修改数据库）
**实现方式**：
- 修改数据库表，`contract_id`允许NULL
- 当`contractId == null`时，使用`sessionId`关联（contractId设为NULL）
- 撤销时根据`undoToken`查找，如果`contractId`为NULL，只返回内容不更新合同表
- 添加清理策略，定期清理过期的NULL记录

**开发难度**：⭐⭐⭐ 中等（2-3小时）
- 需要数据库迁移
- 需要修改保存逻辑
- 需要修改撤销逻辑
- 需要添加清理逻辑（可选）

**优点**：
- ✅ 数据持久化
- ✅ 逻辑相对清晰
- ✅ 统一存储方式

**缺点**：
- ❌ 需要数据库迁移
- ❌ 需要处理NULL记录的清理

**适用场景**：需要持久化，且愿意修改数据库结构

---

## 推荐方案

### 推荐：方案1（内存存储方案）

**理由**：
1. **开发难度适中**：3-4小时可以完成
2. **风险低**：不需要修改数据库，不影响已有功能
3. **适用场景匹配**：新建合同的撤销需求是临时性的，用户保存合同后就会有contractId
4. **实现简单**：只需要添加一个Map和少量逻辑修改

### 实现步骤（方案1）

1. **添加内存存储**（15分钟）
   ```java
   // 在AIChatServiceImpl类中添加
   private final Map<String, ContractEditHistory> unsavedEditHistory = new ConcurrentHashMap<>();
   ```

2. **修改保存逻辑**（30分钟）
   - 当`contractId == null`时，存储到内存Map（key=undoToken）
   - 当`contractId != null`时，正常保存到数据库

3. **修改撤销逻辑**（45分钟）
   - 先从数据库查找
   - 如果找不到，从内存Map查找
   - 如果contractId为null，直接返回内容，不更新合同表

4. **添加清理机制**（可选，1-2小时）
   - 会话过期时清理
   - 定期清理过期记录（超过24小时）

5. **测试**（1小时）

**总时间**：3-4小时

---

## 其他考虑

### 如果选择方案2（数据库允许NULL）
需要：
1. 创建数据库迁移脚本
2. 测试迁移脚本
3. 修改保存和撤销逻辑
4. 添加NULL记录清理策略

**风险**：数据库迁移有风险，需要备份和测试

### 用户体验考虑
- 新建合同时的撤销是合理的需求
- 用户可能多次使用Agent修改，需要支持撤销
- 撤销后应该能继续编辑

### 长期考虑
- 如果未来需要支持分布式部署，方案1不适合
- 如果数据持久化是硬性要求，应选择方案2或4
- 当前单机部署，方案1足够


